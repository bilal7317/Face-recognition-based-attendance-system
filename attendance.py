# -*- coding: utf-8 -*-
"""Attendance.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YSusbxup-HVRUL4K6yyA1bYmrhbYLS7d
"""

#-------------------------------image collection through webcam

import cv2
import time

# Opens the inbuilt camera of laptop to capture video.
webCam = cv2.VideoCapture(0)
currentframe = 0

while (True):
    success, frame = webCam.read()

    # Save Frame by Frame into disk using imwrite method
    cv2.imshow("Output", frame)

    # Capture a frame every 5 seconds
    if currentframe % 20 == 0:
        cv2.imwrite('./ahmad/Frame' + str(currentframe) + '.jpg', frame)

    currentframe += 1

    # currentframe == 10:
    if cv2.waitKey(1) == 13 or int(currentframe) == 2000:
    # if cv2.waitKey(1) & 0xFF == ord('q'):
        break


# C:\Users\muham\Untitled Folder\images\bilal


webCam.release()
cv2.destroyAllWindows()

from google.colab import drive
drive.mount('/content/drive')

#-------------------------------rar file extraction

!unrar x /content/known_faces.rar

#-------------------------------library installation

!pip install face_recognition

!pip install opencv-python-headless

!pip install opencv-python

#-------------------------------Face Recognition Model Training

from imutils import paths
import face_recognition
import argparse
import pickle
import cv2
import os
from google.colab.patches import cv2_imshow


KNOWN_FACES = 'known_faces'
UNKNOWN_FACES = 'unkown_faces'

TOLERANCE = 0.6

MODEL = 'cnn'  # default is 'hog' other one can be 'cnn' if CUDA accelerated deep-learning pretrained model is available

known_face = []
known_name = []

print("Loading tranning data ....")

for name in os.listdir(KNOWN_FACES):

  # loading every image for every subfolder
  for imagename in os.listdir(f'{KNOWN_FACES}/{name}'):
    # Load image
    if imagename.startswith('.'):
        continue
    image = face_recognition.load_image_file(f'{KNOWN_FACES}/{name}/{imagename}')
    face_locations = face_recognition.face_locations(image)
    # If no faces were detected, skip this image
    if not face_locations:
        continue
    encoding = face_recognition.face_encodings(image , model=MODEL)[0]

    #store encodings and name
    known_face.append(encoding)
    known_name.append(name)
print("Loading completed")

print("[INFO] serializing encodings...")
data = {"encoding": known_face, "names": known_name}
f = open("encoding4.pickle", "wb")
f.write(pickle.dumps(data))
f.close()

  # cv2_imshow(image)



4#-------------------------------AI model testing

from itertools import count
from pickletools import optimize
from imutils import paths
import face_recognition
import argparse
import pickle
import cv2
import numpy as np
from google.colab.patches import cv2_imshow
import os
from PIL import Image
from io import BytesIO
import base64



# load the known faces and embeddings
print("[INFO] loading encodings...")
# data = pickle.loads(open("/content/encoding.pickle", "rb").read())
data = pickle.loads(open("/content/encoding4.pickle", "rb").read())


names = []

attend = {"1.jpg","2.jpg","3.jpg","4.jpg","5.jpg"}
print(attend)

print(attend.type)


while(1){

image = cv2.imread("123.jpg")
image_resized = cv2.resize(image, (800,600), interpolation=cv2.INTER_AREA)

rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
	# detect the (x, y)-coordinates of the bounding boxes corresponding
	# to each face in the input image, then compute the facial embeddings
	# for each face
print("[INFO] recognizing faces...")
boxes = face_recognition.face_locations(rgb) #model="cnn")
encodings = face_recognition.face_encodings(rgb, boxes)
	# initialize the list of names for each face detected
names = []

	# loop over the facial embeddings
for encoding in encodings:
	# attempt to match each face in the input image to our known
		# encodings
	matches = face_recognition.compare_faces(data["encoding"],encoding,tolerance = 0.4)
	name = "Unknown"

		# check to see if we have found a match
	if True in matches:
			# find the indexes of all matched faces then initialize a
			# dictionary to count the total number of times each face
			# was matched
		matchedIdxs = [i for (i, b) in enumerate(matches) if b]
		counts = {}
			# loop over the matched indexes and maintain a count for
			# each recognized face face

		for i in matchedIdxs:
			name = data["names"][i]
			counts[name] = counts.get(name, 0) + 1
			# determine the recognized face with the largest number of
			# votes (note: in the event of an unlikely tie Python will
			# select first entry in the dictionary)
			name = max(counts, key=counts.get)



		# update the list of names
	names.append(name)
		#print(matchedIdxs)
# 	# loop over the recognized faces
# for ((top, right, bottom, left), name) in zip(boxes, names):
# 		# draw the predicted face name on the image
# 	cv2.rectangle(image_resized, (left, top), (right, bottom), (0, 255, 0), 2)
# 	y = top - 15 if top - 15 > 15 else top + 15
	# cv2.imwrite('output_'+fname, image_resized)
	# return names,'output_'+ fname


print(names)
# # show the output image
# cv2_imshow("Image", image_resized)
# #cv2.imwrite('uploads/output_'+ fname, image_resized)
# cv2.waitKey(0)
# cv2.destroyAllWindows()

#this line was added for github status change



import pandas as pd
from datetime import datetime

def mark_attendance(names, file_path):
    # Read the existing excel file
    df = pd.read_excel(file_path)
    print(f"Dataframe before updating:\n{df}")

    # Get today's date in 'yyyy-mm-dd' format
    today_date = datetime.today().strftime('%Y-%m-%d')
    print(f"Today's date: {today_date}")

    # Get the index of today's date in the dataframe
    index = df[df['Date'] == today_date].index[0]
    print(f"Index of today's date in the dataframe: {index}")

    # Iterate over the recognized names and mark 'P' for presence
    for name in names:
        if name in df.columns:
            df.at[index, name] = 'P'
            print(f"Marked 'P' for {name}")
        else:
            print(f"Student {name} does not exist in the sheet.")

    # Save the updated dataframe back to the Excel file
    df.to_excel(file_path, index=False)
    print(f"Dataframe after updating:\n{df}")

# Now call the function with your data
# Replace 'july_attendance.xlsx' with the path to your file
mark_attendance(names, 'july_attendance.xlsx')

}



import pandas as pd
from datetime import datetime

def mark_attendance(names, file_path):
    # Read the existing excel file
    df = pd.read_excel(file_path)
    print(f"Dataframe before updating:\n{df}")

    # Get today's date in 'yyyy-mm-dd' format
    today_date = datetime.today().strftime('%Y-%m-%d')
    print(f"Today's date: {today_date}")

    # Get the index of today's date in the dataframe
    index = df[df['Date'] == today_date].index[0]
    print(f"Index of today's date in the dataframe: {index}")

    # Iterate over the recognized names and mark 'P' for presence
    for name in names:
        if name in df.columns:
            df.at[index, name] = 'P'
            print(f"Marked 'P' for {name}")
        else:
            print(f"Student {name} does not exist in the sheet.")

    # Save the updated dataframe back to the Excel file
    df.to_excel(file_path, index=False)
    print(f"Dataframe after updating:\n{df}")

# Now call the function with your data
# Replace 'july_attendance.xlsx' with the path to your file
mark_attendance(['ahmad', 'qasim'], 'july_attendance.xlsx')

!pip install pandas openpyxl

import pandas as pd
from datetime import date, timedelta

def create_attendance_sheet(students, file_path):
    # Get the current year and month
    year, month = date.today().year, date.today().month

    # Compute the first and last day of the current month
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year+1, 1, 1) - timedelta(days=1)
    else:
        end_date = date(year, month+1, 1) - timedelta(days=1)

    # Create a list of dates for the current month
    date_list = pd.date_range(start_date, end_date).tolist()
    date_list = [date.strftime('%Y-%m-%d') for date in date_list]

    # Create a dictionary with the dates and 'A' for each student
    data = {'Date': date_list}
    data.update({student: [' ']*len(date_list) for student in students})

    # Convert the dictionary to a pandas dataframe
    df = pd.DataFrame(data)

    # Save the dataframe to an Excel file
    df.to_excel(file_path, index=False)

# Now call the function with your data
# Replace 'attendance.xlsx' with the path to your file
create_attendance_sheet(['ahmad', 'badar', 'bilal','haris','qasim','saad','sarmad','sulaiman','umar'], 'july_attendance.xlsx')

import pandas as pd
from datetime import datetime

def mark_attendance(names, file_path):
    # Read the existing excel file
    df = pd.read_excel(file_path)
    print(f"Dataframe before updating:\n{df}")

    # Get today's date in 'yyyy-mm-dd' format
    today_date = datetime.today().strftime('%Y-%m-%d')
    print(f"Today's date: {today_date}")

    # Get the index of today's date in the dataframe
    index = df[df['Date'] == today_date].index[0]
    print(f"Index of today's date in the dataframe: {index}")

    # Iterate over the recognized names and mark 'P' for presence
    for name in names:
        if name in df.columns:
            df.at[index, name] = 'P'
            print(f"Marked 'P' for {name}")
        else:
            print(f"Student {name} does not exist in the sheet.")

    # Save the updated dataframe back to the Excel file
    df.to_excel(file_path, index=False)
    print(f"Dataframe after updating:\n{df}")

# Now call the function with your data
# Replace 'july_attendance.xlsx' with the path to your file
mark_attendance(['ahmad', 'qasim'], 'july_attendance.xlsx')

import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText

# Setup the MIME
message = MIMEMultipart()
message['From'] = 'expaccx@gmail.com'
message['To'] = 'muhammadbilal7317@gmail.com'
message['Subject'] = 'Email Subject'  # The subject line

# The body and the attachments for the mail
message.attach(MIMEText('Email body', 'plain'))

# Use gmail with port
mail = smtplib.SMTP('smtp.gmail.com', 587)

# enable security
mail.starttls()

# Authentication
mail.login('expaccx@gmail.com', 'yzkdptnojaxwnhui')

# send the mail
mail.sendmail(message['From'], message['To'], message.as_string())

# end the connection
mail.quit()

import cv2
import os

# Load pre-trained face detector from OpenCV
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + 'haarcascade_frontalface_default.xml')

# Create a new directory to store the images
image_dir = './images/ahmad'
os.makedirs(image_dir, exist_ok=True)

# Open the webcam
cap = cv2.VideoCapture(0)

cap.set(cv2.CAP_PROP_FRAME_WIDTH, 1920)
cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 1080)


# Loop to save 100 images
i = 0
while i < 100:
    # Capture frame-by-frame
    ret, frame = cap.read()

    # Check if frame is not empty
    if not ret:
        break

    # Convert to grayscale for face detection
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Perform face detection
    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5, minSize=(40, 40))

    # Check if any face is detected
    if len(faces) > 0:
        # Iterate over all detected faces
        for (x, y, w, h) in faces:
            # Extract face
            face = frame[y:y+h, x:x+w]

            # Resize face to 720x720
            face_resized = cv2.resize(face, (720, 720), interpolation=cv2.INTER_LANCZOS4)
    #         face_resized = cv2.resize(face, (720, 720))

            # Define filename
            filename = os.path.join(image_dir, f'webcam_face_{i}.jpg')

            # Save the image
            cv2.imwrite(filename, face_resized)

        # Increment the image counter
        i += 1

    # Display the resulting frame
    cv2.imshow('Capturing Images', frame)

    # Wait for 1 ms before capturing the next frame
    # If 'q' is pressed on the keyboard,
    # exit the loop before capturing 100 images
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# When everything is done, release the capture
cap.release()
cv2.destroyAllWindows()

attend = {"1.jpg","2.jpg","3.jpg","4.jpg","5.jpg"}
print(attend)

####
# # print(attend.)

# pip install yagmail

# import yagmail

# def send_email():
#     yag = yagmail.SMTP('expaccx@gmail.com', 'roro19jy')

#     subject = 'Hello, World!'
#     body = 'This is the body of the email.'

#     yag.send('muhammadbilal7317@gmail.com', subject, body)
#     print("Email sent successfully!")


# # Call the function to send email
# send_email()

# import yagmail

# # Store your password in your system's keyring
# yagmail.register('expaccx@gmail.com', 'roro19jy')

# # Now you can send email without specifying password every time
# yag = yagmail.SMTP('expaccx@gmail.com')

# subject = 'Hello, World!'
# body = 'This is the body of the email.'

# yag.send('muhammadbilal7317@gmail.com', subject, body)
# print("Email sent successfully!")

# pip install keyring keyrings.alt

# export EMAIL="expaccx@gmail.com"
# export PASSWORD="roro19jy"

# import yagmail
# import os

# def send_email():
#     yag = yagmail.SMTP('expaccx@gmail.com','roro19jy')

#     subject = 'Hello, World!'
#     body = 'This is the body of the email.'

#     yag.send('muhammadbilal7317@gmail.com', subject, body)
#     print("Email sent successfully!")

# # Call the function to send email
# send_email()
####